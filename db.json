{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[],"Cache":[{"_id":"source/_posts/http.md","hash":"c9ea5389fc3912cf3aa5dc747d012bdd6d85dd13","modified":1514876115000},{"_id":"source/_posts/let.md","hash":"d4c6c8e193c53e8bb779362adafa087394a72d40","modified":1514876115000},{"_id":"source/_posts/this.md","hash":"2e135075c4f161083f51bedb318270f639dcfa67","modified":1514876115000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"图解http","date":"2017-04-28T16:00:00.000Z","_content":"### Http与Https的对比\n1. http通信使用明文，内容可能被窃听\n2. 不验证通信方的身份，有可能遭到伪装\n3. 无法验证明文的完整性，可能已经遭到篡改\n\n**Https=加密+认证+完整性保护**\n\n---\n\n### 网络基础\n#### TCP/IP协议\n- 把与互联网相关的协议集合起来的总称\n- 应用层（FTP、DNS、HTTP）、传输层（TCP、UDP）、网络层（IP）、数据链路层\n- 数据传输时候的封装\n- IP协议：负责传输，IP地址和MAC地址（ARP协议：解析地址）\n- TCP三次握手\n    - Client发送带有SYN标志的数据包给对方\n    - 接收端收到并回传一个STYN／ACK标志的数据包\n    - Client最后回传一个ACK的数据包，表示握手结束\n-  URL：uniform resource location 统一资源定位符\n-  URI：uniform resource identifier 统一资源标识\n\n---\n<!-- more -->\n\n### HTTP协议(无状态协议)\n#### HTTP报文：用于HTTP协议交互的信息（报文首部+报文主体）\n- 报文主体用于传输实体主体，通常情况下，报文主体等于实体主体，只有在传输过程中进行编码操作时，实体主体内容发生变化，导致与报文主体发生差异\n- 内容编码：由客户端解码（gzip、compress、deflate、identify）\n- 分块传输编码：把实体主体分块，由客户端负责解码\n- 获取部分范围内的请求：首部字段Range，成功206 Partial Content 否则200 OK\n- 内容协商\n\n---\n\n#### 请求报文：方法+请求URI+协议版本号+可选请求首部+内容实体\n1. 方法\n- GET：用于请求资源\n- POST：用于传输实体的主体\n- PUT：用于传输文件（204 No Content，已存在）\n- HEAD：获得报文首部，用于确认URI有效期以及资源的更新日期等\n- DELETE：删除文件，与PUT相反（204 No Content，已删除）\n- OPTIONS：询问支持的方法\n- TRACE：用于追踪路径，Max-Forwards\n- CONNECT：要求用隧道协议连接代理（要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要是通过SSL和TLS协议把通信内容加密后通过网络隧道传输）\n2. 使用方法下达命令\n3. 持久连接：Keep-alive，只要任意一端没有明确表示要断开，就保持TCP连接状态\n- 优点：在于减少了 TCP 连接的重复建立和断开所造成的 额外开销,减轻了服务器端的负载。另外,减少开销的那部分时间,使 HTTP 请求和响应能够更早地结束,这样 Web 页面的显示速度也就相应 提高了。\n4. Pipeling：同时并行发送多个请求\n\n---\n\n#### 响应报文：协议版本+状态码+解释状态吗的状态短语+可选响应首部+内容实体\n\n---\n\n### 通信数据转发程序:代理、网关、隧道\n代理：转发时,需要附加 Via 首部字段以标记出经过的主机信息。\n- 利用缓存技术减少网络带宽的流量，组织内部针对特定网址的访问控制，以获取访问日志为目的\n\n网管：利用网关可以由 HTTP 请求转化为其他协议通信，提高通信的安全性。\n\n隧道：隧道的目的是确保客户端能与服务器（远距离）进行安全的通信。\n\n---\n\n### 首部\n#### 通用报文首部\n- Cache-Control：缓存机制\n  - 缓存请求指令：no-cache,no-store,max-age,max-stale,**only-if-cached**(客户端仅在缓存服务器本地缓存目标资源的情况下才会返回，否则504 Gateway Timeout)\n  - 混存响应指令：public,private,no-cache,no-store,must-revalidate,proxy-revalidate\n- Upgrade：用于检测HTTP协议以及其他协议是否可使用更高的版本进行通信，参数可以是一个完全不同的协议\n- Connection：控制不再转发给代理的首部名称，管理持久链接\n- Date：报文创建的时间\n- Pragma：要求所有的中间服务器不返回缓存的资源\n- Trailer：事先说明报文主体里有哪些首部字段\n- Transfer-Encoding\n- Via：为了追踪传输路径，通常与trace一起使用\n\n---\n\n#### 请求报文首部\n- Accept\n- Accetpt-Charset\n- Accept-Language\n- Accept-Encoding\n- Authorization：用于告知服务器，用户代理的认证信息\n- Expect：（否则417）\n- From：邮箱\n- Host\n- If-Match：与ETag相互配合使用\n- If-Modified-Since\n- If-None-Match\n- If-Range\n- If-Unmodified-Since\n- Max-Forwards\n- Proxy-Authorization\n- Range\n- Referer：URI\n- User-Agent\n\n---\n\n#### 响应报文首部\n- Accept-Ranges：bytes|none\n- Age\n- ETag：告知客户端实体标识\n- Location：URI\n- Proxy-Authenticate\n- Retry-After\n- Server\n- Vary：对缓存进行控制\n- WWW-Authenticate\n\n---\n\n#### 实体首部字段\n- Allow\n- Content-Encoding\n- Content-Language\n- Content-Length\n- Content-Location\n- Content-MD5\n- Content-Range\n- Content-Types\n- Expires\n- Last-Modified\n\n---\n\n#### Cookie相关\n- 响应首部字段：Set-Cookie\n- 请求首部字段：Cookie\n- 字段：name,value,domain,path,expires,secure(只有在HTTPS安全通信是才发送Cookie),HttpOnly（使js无法获得Cookie，防止XSS）\n\n\n---\n\n### 状态码\n\n状态码   | 类别 | 原因短语\n---|---|---\n1XX | Informational（信息类状态码）| 接受的请求正在处理\n2XX | Success（成功状态码）| 请求正常处理完毕\n3XX | Redirection（重定向状态码） | 需要附加操作才能完成请求\n4XX | Client Error （客户端出错）| 服务器端无法处理请求\n5XX | Server Error（服务端报错）| 服务器端处理请求报错\n\n---\n\n\n#### 204 No Content\n成功处理，但在返回的响应报文中不包括实体的主体部分\n一般用于从客户端向服务器端发送信息，而对客户端不需要发送新信息的情况，例如PUT、DELEDTE\n#### 206 Partial Content\n表示客户端进行了范围请求，而服务器端成功地执行了这部分请求，响应报文中包含由Content-Range指定范围内的实体内容\n\n---\n\n#### 301 Move Permanently\n永久性重定向，更新URI\n#### 302 Found\n临时重定向，本次更新URI\n#### 303 See Other\n表示请求的资源存在另一个URI，应使用GET获取资源\n#### 304 Not Modified\n不包含任何响应的主体部分，一般和缓存相关的首部配合使用（Cacha-Control、If-Modified-Since）\n#### 307 Temporary Redirect\n临时重定向，与302不同，307不会把POST改成GET\n一般301 302 303返回时，基本上所有的浏览器都会把POST更换成GET方法，并删除请求报文中的主体，之后请求会自动再发送\n\n---\n\n#### 400 Bad Request\n请求报文中出现语法错误\n#### 401 Unauthorized\n表示发送的请求需要有通过HTTP认证的信息。包含401的响应必须包含一个适用于被请求资源的WWW-Authenticate的首部用于质询用户信息\n浏览器收到401响应，会弹出认证用的对话窗口\n#### 403 Fobidden\n访问被拒绝\n#### 404 Not Found\n找不到请求的资源\n\n---\n\n#### 501 Internal Server Error\n服务器端在执行请求时候发生了错误\n#### 503 Service Unavaible\n服务器端负载超荷活着在维护，无法处理请求。如果知道处理状况的时间，最好加上Retry-After的首部返回客户端","source":"_posts/http.md","raw":"---\ntitle: 图解http\ndate: 2017-04-29\ntags: \n  - http\n---\n### Http与Https的对比\n1. http通信使用明文，内容可能被窃听\n2. 不验证通信方的身份，有可能遭到伪装\n3. 无法验证明文的完整性，可能已经遭到篡改\n\n**Https=加密+认证+完整性保护**\n\n---\n\n### 网络基础\n#### TCP/IP协议\n- 把与互联网相关的协议集合起来的总称\n- 应用层（FTP、DNS、HTTP）、传输层（TCP、UDP）、网络层（IP）、数据链路层\n- 数据传输时候的封装\n- IP协议：负责传输，IP地址和MAC地址（ARP协议：解析地址）\n- TCP三次握手\n    - Client发送带有SYN标志的数据包给对方\n    - 接收端收到并回传一个STYN／ACK标志的数据包\n    - Client最后回传一个ACK的数据包，表示握手结束\n-  URL：uniform resource location 统一资源定位符\n-  URI：uniform resource identifier 统一资源标识\n\n---\n<!-- more -->\n\n### HTTP协议(无状态协议)\n#### HTTP报文：用于HTTP协议交互的信息（报文首部+报文主体）\n- 报文主体用于传输实体主体，通常情况下，报文主体等于实体主体，只有在传输过程中进行编码操作时，实体主体内容发生变化，导致与报文主体发生差异\n- 内容编码：由客户端解码（gzip、compress、deflate、identify）\n- 分块传输编码：把实体主体分块，由客户端负责解码\n- 获取部分范围内的请求：首部字段Range，成功206 Partial Content 否则200 OK\n- 内容协商\n\n---\n\n#### 请求报文：方法+请求URI+协议版本号+可选请求首部+内容实体\n1. 方法\n- GET：用于请求资源\n- POST：用于传输实体的主体\n- PUT：用于传输文件（204 No Content，已存在）\n- HEAD：获得报文首部，用于确认URI有效期以及资源的更新日期等\n- DELETE：删除文件，与PUT相反（204 No Content，已删除）\n- OPTIONS：询问支持的方法\n- TRACE：用于追踪路径，Max-Forwards\n- CONNECT：要求用隧道协议连接代理（要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要是通过SSL和TLS协议把通信内容加密后通过网络隧道传输）\n2. 使用方法下达命令\n3. 持久连接：Keep-alive，只要任意一端没有明确表示要断开，就保持TCP连接状态\n- 优点：在于减少了 TCP 连接的重复建立和断开所造成的 额外开销,减轻了服务器端的负载。另外,减少开销的那部分时间,使 HTTP 请求和响应能够更早地结束,这样 Web 页面的显示速度也就相应 提高了。\n4. Pipeling：同时并行发送多个请求\n\n---\n\n#### 响应报文：协议版本+状态码+解释状态吗的状态短语+可选响应首部+内容实体\n\n---\n\n### 通信数据转发程序:代理、网关、隧道\n代理：转发时,需要附加 Via 首部字段以标记出经过的主机信息。\n- 利用缓存技术减少网络带宽的流量，组织内部针对特定网址的访问控制，以获取访问日志为目的\n\n网管：利用网关可以由 HTTP 请求转化为其他协议通信，提高通信的安全性。\n\n隧道：隧道的目的是确保客户端能与服务器（远距离）进行安全的通信。\n\n---\n\n### 首部\n#### 通用报文首部\n- Cache-Control：缓存机制\n  - 缓存请求指令：no-cache,no-store,max-age,max-stale,**only-if-cached**(客户端仅在缓存服务器本地缓存目标资源的情况下才会返回，否则504 Gateway Timeout)\n  - 混存响应指令：public,private,no-cache,no-store,must-revalidate,proxy-revalidate\n- Upgrade：用于检测HTTP协议以及其他协议是否可使用更高的版本进行通信，参数可以是一个完全不同的协议\n- Connection：控制不再转发给代理的首部名称，管理持久链接\n- Date：报文创建的时间\n- Pragma：要求所有的中间服务器不返回缓存的资源\n- Trailer：事先说明报文主体里有哪些首部字段\n- Transfer-Encoding\n- Via：为了追踪传输路径，通常与trace一起使用\n\n---\n\n#### 请求报文首部\n- Accept\n- Accetpt-Charset\n- Accept-Language\n- Accept-Encoding\n- Authorization：用于告知服务器，用户代理的认证信息\n- Expect：（否则417）\n- From：邮箱\n- Host\n- If-Match：与ETag相互配合使用\n- If-Modified-Since\n- If-None-Match\n- If-Range\n- If-Unmodified-Since\n- Max-Forwards\n- Proxy-Authorization\n- Range\n- Referer：URI\n- User-Agent\n\n---\n\n#### 响应报文首部\n- Accept-Ranges：bytes|none\n- Age\n- ETag：告知客户端实体标识\n- Location：URI\n- Proxy-Authenticate\n- Retry-After\n- Server\n- Vary：对缓存进行控制\n- WWW-Authenticate\n\n---\n\n#### 实体首部字段\n- Allow\n- Content-Encoding\n- Content-Language\n- Content-Length\n- Content-Location\n- Content-MD5\n- Content-Range\n- Content-Types\n- Expires\n- Last-Modified\n\n---\n\n#### Cookie相关\n- 响应首部字段：Set-Cookie\n- 请求首部字段：Cookie\n- 字段：name,value,domain,path,expires,secure(只有在HTTPS安全通信是才发送Cookie),HttpOnly（使js无法获得Cookie，防止XSS）\n\n\n---\n\n### 状态码\n\n状态码   | 类别 | 原因短语\n---|---|---\n1XX | Informational（信息类状态码）| 接受的请求正在处理\n2XX | Success（成功状态码）| 请求正常处理完毕\n3XX | Redirection（重定向状态码） | 需要附加操作才能完成请求\n4XX | Client Error （客户端出错）| 服务器端无法处理请求\n5XX | Server Error（服务端报错）| 服务器端处理请求报错\n\n---\n\n\n#### 204 No Content\n成功处理，但在返回的响应报文中不包括实体的主体部分\n一般用于从客户端向服务器端发送信息，而对客户端不需要发送新信息的情况，例如PUT、DELEDTE\n#### 206 Partial Content\n表示客户端进行了范围请求，而服务器端成功地执行了这部分请求，响应报文中包含由Content-Range指定范围内的实体内容\n\n---\n\n#### 301 Move Permanently\n永久性重定向，更新URI\n#### 302 Found\n临时重定向，本次更新URI\n#### 303 See Other\n表示请求的资源存在另一个URI，应使用GET获取资源\n#### 304 Not Modified\n不包含任何响应的主体部分，一般和缓存相关的首部配合使用（Cacha-Control、If-Modified-Since）\n#### 307 Temporary Redirect\n临时重定向，与302不同，307不会把POST改成GET\n一般301 302 303返回时，基本上所有的浏览器都会把POST更换成GET方法，并删除请求报文中的主体，之后请求会自动再发送\n\n---\n\n#### 400 Bad Request\n请求报文中出现语法错误\n#### 401 Unauthorized\n表示发送的请求需要有通过HTTP认证的信息。包含401的响应必须包含一个适用于被请求资源的WWW-Authenticate的首部用于质询用户信息\n浏览器收到401响应，会弹出认证用的对话窗口\n#### 403 Fobidden\n访问被拒绝\n#### 404 Not Found\n找不到请求的资源\n\n---\n\n#### 501 Internal Server Error\n服务器端在执行请求时候发生了错误\n#### 503 Service Unavaible\n服务器端负载超荷活着在维护，无法处理请求。如果知道处理状况的时间，最好加上Retry-After的首部返回客户端","slug":"http","published":1,"updated":"2018-01-02T06:55:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbxa81t80000dys68cwmqpu5","content":"<h3 id=\"Http与Https的对比\"><a href=\"#Http与Https的对比\" class=\"headerlink\" title=\"Http与Https的对比\"></a>Http与Https的对比</h3><ol>\n<li>http通信使用明文，内容可能被窃听</li>\n<li>不验证通信方的身份，有可能遭到伪装</li>\n<li>无法验证明文的完整性，可能已经遭到篡改</li>\n</ol>\n<p><strong>Https=加密+认证+完整性保护</strong></p>\n<hr>\n<h3 id=\"网络基础\"><a href=\"#网络基础\" class=\"headerlink\" title=\"网络基础\"></a>网络基础</h3><h4 id=\"TCP-IP协议\"><a href=\"#TCP-IP协议\" class=\"headerlink\" title=\"TCP/IP协议\"></a>TCP/IP协议</h4><ul>\n<li>把与互联网相关的协议集合起来的总称</li>\n<li>应用层（FTP、DNS、HTTP）、传输层（TCP、UDP）、网络层（IP）、数据链路层</li>\n<li>数据传输时候的封装</li>\n<li>IP协议：负责传输，IP地址和MAC地址（ARP协议：解析地址）</li>\n<li>TCP三次握手<ul>\n<li>Client发送带有SYN标志的数据包给对方</li>\n<li>接收端收到并回传一个STYN／ACK标志的数据包</li>\n<li>Client最后回传一个ACK的数据包，表示握手结束</li>\n</ul>\n</li>\n<li>URL：uniform resource location 统一资源定位符</li>\n<li>URI：uniform resource identifier 统一资源标识</li>\n</ul>\n<hr>\n<a id=\"more\"></a>\n<h3 id=\"HTTP协议-无状态协议\"><a href=\"#HTTP协议-无状态协议\" class=\"headerlink\" title=\"HTTP协议(无状态协议)\"></a>HTTP协议(无状态协议)</h3><h4 id=\"HTTP报文：用于HTTP协议交互的信息（报文首部-报文主体）\"><a href=\"#HTTP报文：用于HTTP协议交互的信息（报文首部-报文主体）\" class=\"headerlink\" title=\"HTTP报文：用于HTTP协议交互的信息（报文首部+报文主体）\"></a>HTTP报文：用于HTTP协议交互的信息（报文首部+报文主体）</h4><ul>\n<li>报文主体用于传输实体主体，通常情况下，报文主体等于实体主体，只有在传输过程中进行编码操作时，实体主体内容发生变化，导致与报文主体发生差异</li>\n<li>内容编码：由客户端解码（gzip、compress、deflate、identify）</li>\n<li>分块传输编码：把实体主体分块，由客户端负责解码</li>\n<li>获取部分范围内的请求：首部字段Range，成功206 Partial Content 否则200 OK</li>\n<li>内容协商</li>\n</ul>\n<hr>\n<h4 id=\"请求报文：方法-请求URI-协议版本号-可选请求首部-内容实体\"><a href=\"#请求报文：方法-请求URI-协议版本号-可选请求首部-内容实体\" class=\"headerlink\" title=\"请求报文：方法+请求URI+协议版本号+可选请求首部+内容实体\"></a>请求报文：方法+请求URI+协议版本号+可选请求首部+内容实体</h4><ol>\n<li>方法</li>\n</ol>\n<ul>\n<li>GET：用于请求资源</li>\n<li>POST：用于传输实体的主体</li>\n<li>PUT：用于传输文件（204 No Content，已存在）</li>\n<li>HEAD：获得报文首部，用于确认URI有效期以及资源的更新日期等</li>\n<li>DELETE：删除文件，与PUT相反（204 No Content，已删除）</li>\n<li>OPTIONS：询问支持的方法</li>\n<li>TRACE：用于追踪路径，Max-Forwards</li>\n<li>CONNECT：要求用隧道协议连接代理（要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要是通过SSL和TLS协议把通信内容加密后通过网络隧道传输）</li>\n</ul>\n<ol>\n<li>使用方法下达命令</li>\n<li>持久连接：Keep-alive，只要任意一端没有明确表示要断开，就保持TCP连接状态</li>\n</ol>\n<ul>\n<li>优点：在于减少了 TCP 连接的重复建立和断开所造成的 额外开销,减轻了服务器端的负载。另外,减少开销的那部分时间,使 HTTP 请求和响应能够更早地结束,这样 Web 页面的显示速度也就相应 提高了。</li>\n</ul>\n<ol>\n<li>Pipeling：同时并行发送多个请求</li>\n</ol>\n<hr>\n<h4 id=\"响应报文：协议版本-状态码-解释状态吗的状态短语-可选响应首部-内容实体\"><a href=\"#响应报文：协议版本-状态码-解释状态吗的状态短语-可选响应首部-内容实体\" class=\"headerlink\" title=\"响应报文：协议版本+状态码+解释状态吗的状态短语+可选响应首部+内容实体\"></a>响应报文：协议版本+状态码+解释状态吗的状态短语+可选响应首部+内容实体</h4><hr>\n<h3 id=\"通信数据转发程序-代理、网关、隧道\"><a href=\"#通信数据转发程序-代理、网关、隧道\" class=\"headerlink\" title=\"通信数据转发程序:代理、网关、隧道\"></a>通信数据转发程序:代理、网关、隧道</h3><p>代理：转发时,需要附加 Via 首部字段以标记出经过的主机信息。</p>\n<ul>\n<li>利用缓存技术减少网络带宽的流量，组织内部针对特定网址的访问控制，以获取访问日志为目的</li>\n</ul>\n<p>网管：利用网关可以由 HTTP 请求转化为其他协议通信，提高通信的安全性。</p>\n<p>隧道：隧道的目的是确保客户端能与服务器（远距离）进行安全的通信。</p>\n<hr>\n<h3 id=\"首部\"><a href=\"#首部\" class=\"headerlink\" title=\"首部\"></a>首部</h3><h4 id=\"通用报文首部\"><a href=\"#通用报文首部\" class=\"headerlink\" title=\"通用报文首部\"></a>通用报文首部</h4><ul>\n<li>Cache-Control：缓存机制<ul>\n<li>缓存请求指令：no-cache,no-store,max-age,max-stale,<strong>only-if-cached</strong>(客户端仅在缓存服务器本地缓存目标资源的情况下才会返回，否则504 Gateway Timeout)</li>\n<li>混存响应指令：public,private,no-cache,no-store,must-revalidate,proxy-revalidate</li>\n</ul>\n</li>\n<li>Upgrade：用于检测HTTP协议以及其他协议是否可使用更高的版本进行通信，参数可以是一个完全不同的协议</li>\n<li>Connection：控制不再转发给代理的首部名称，管理持久链接</li>\n<li>Date：报文创建的时间</li>\n<li>Pragma：要求所有的中间服务器不返回缓存的资源</li>\n<li>Trailer：事先说明报文主体里有哪些首部字段</li>\n<li>Transfer-Encoding</li>\n<li>Via：为了追踪传输路径，通常与trace一起使用</li>\n</ul>\n<hr>\n<h4 id=\"请求报文首部\"><a href=\"#请求报文首部\" class=\"headerlink\" title=\"请求报文首部\"></a>请求报文首部</h4><ul>\n<li>Accept</li>\n<li>Accetpt-Charset</li>\n<li>Accept-Language</li>\n<li>Accept-Encoding</li>\n<li>Authorization：用于告知服务器，用户代理的认证信息</li>\n<li>Expect：（否则417）</li>\n<li>From：邮箱</li>\n<li>Host</li>\n<li>If-Match：与ETag相互配合使用</li>\n<li>If-Modified-Since</li>\n<li>If-None-Match</li>\n<li>If-Range</li>\n<li>If-Unmodified-Since</li>\n<li>Max-Forwards</li>\n<li>Proxy-Authorization</li>\n<li>Range</li>\n<li>Referer：URI</li>\n<li>User-Agent</li>\n</ul>\n<hr>\n<h4 id=\"响应报文首部\"><a href=\"#响应报文首部\" class=\"headerlink\" title=\"响应报文首部\"></a>响应报文首部</h4><ul>\n<li>Accept-Ranges：bytes|none</li>\n<li>Age</li>\n<li>ETag：告知客户端实体标识</li>\n<li>Location：URI</li>\n<li>Proxy-Authenticate</li>\n<li>Retry-After</li>\n<li>Server</li>\n<li>Vary：对缓存进行控制</li>\n<li>WWW-Authenticate</li>\n</ul>\n<hr>\n<h4 id=\"实体首部字段\"><a href=\"#实体首部字段\" class=\"headerlink\" title=\"实体首部字段\"></a>实体首部字段</h4><ul>\n<li>Allow</li>\n<li>Content-Encoding</li>\n<li>Content-Language</li>\n<li>Content-Length</li>\n<li>Content-Location</li>\n<li>Content-MD5</li>\n<li>Content-Range</li>\n<li>Content-Types</li>\n<li>Expires</li>\n<li>Last-Modified</li>\n</ul>\n<hr>\n<h4 id=\"Cookie相关\"><a href=\"#Cookie相关\" class=\"headerlink\" title=\"Cookie相关\"></a>Cookie相关</h4><ul>\n<li>响应首部字段：Set-Cookie</li>\n<li>请求首部字段：Cookie</li>\n<li>字段：name,value,domain,path,expires,secure(只有在HTTPS安全通信是才发送Cookie),HttpOnly（使js无法获得Cookie，防止XSS）</li>\n</ul>\n<hr>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>类别</th>\n<th>原因短语</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td>Informational（信息类状态码）</td>\n<td>接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success（成功状态码）</td>\n<td>请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection（重定向状态码）</td>\n<td>需要附加操作才能完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error （客户端出错）</td>\n<td>服务器端无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error（服务端报错）</td>\n<td>服务器端处理请求报错</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h4 id=\"204-No-Content\"><a href=\"#204-No-Content\" class=\"headerlink\" title=\"204 No Content\"></a>204 No Content</h4><p>成功处理，但在返回的响应报文中不包括实体的主体部分<br>一般用于从客户端向服务器端发送信息，而对客户端不需要发送新信息的情况，例如PUT、DELEDTE</p>\n<h4 id=\"206-Partial-Content\"><a href=\"#206-Partial-Content\" class=\"headerlink\" title=\"206 Partial Content\"></a>206 Partial Content</h4><p>表示客户端进行了范围请求，而服务器端成功地执行了这部分请求，响应报文中包含由Content-Range指定范围内的实体内容</p>\n<hr>\n<h4 id=\"301-Move-Permanently\"><a href=\"#301-Move-Permanently\" class=\"headerlink\" title=\"301 Move Permanently\"></a>301 Move Permanently</h4><p>永久性重定向，更新URI</p>\n<h4 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a>302 Found</h4><p>临时重定向，本次更新URI</p>\n<h4 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h4><p>表示请求的资源存在另一个URI，应使用GET获取资源</p>\n<h4 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a>304 Not Modified</h4><p>不包含任何响应的主体部分，一般和缓存相关的首部配合使用（Cacha-Control、If-Modified-Since）</p>\n<h4 id=\"307-Temporary-Redirect\"><a href=\"#307-Temporary-Redirect\" class=\"headerlink\" title=\"307 Temporary Redirect\"></a>307 Temporary Redirect</h4><p>临时重定向，与302不同，307不会把POST改成GET<br>一般301 302 303返回时，基本上所有的浏览器都会把POST更换成GET方法，并删除请求报文中的主体，之后请求会自动再发送</p>\n<hr>\n<h4 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h4><p>请求报文中出现语法错误</p>\n<h4 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h4><p>表示发送的请求需要有通过HTTP认证的信息。包含401的响应必须包含一个适用于被请求资源的WWW-Authenticate的首部用于质询用户信息<br>浏览器收到401响应，会弹出认证用的对话窗口</p>\n<h4 id=\"403-Fobidden\"><a href=\"#403-Fobidden\" class=\"headerlink\" title=\"403 Fobidden\"></a>403 Fobidden</h4><p>访问被拒绝</p>\n<h4 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h4><p>找不到请求的资源</p>\n<hr>\n<h4 id=\"501-Internal-Server-Error\"><a href=\"#501-Internal-Server-Error\" class=\"headerlink\" title=\"501 Internal Server Error\"></a>501 Internal Server Error</h4><p>服务器端在执行请求时候发生了错误</p>\n<h4 id=\"503-Service-Unavaible\"><a href=\"#503-Service-Unavaible\" class=\"headerlink\" title=\"503 Service Unavaible\"></a>503 Service Unavaible</h4><p>服务器端负载超荷活着在维护，无法处理请求。如果知道处理状况的时间，最好加上Retry-After的首部返回客户端</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Http与Https的对比\"><a href=\"#Http与Https的对比\" class=\"headerlink\" title=\"Http与Https的对比\"></a>Http与Https的对比</h3><ol>\n<li>http通信使用明文，内容可能被窃听</li>\n<li>不验证通信方的身份，有可能遭到伪装</li>\n<li>无法验证明文的完整性，可能已经遭到篡改</li>\n</ol>\n<p><strong>Https=加密+认证+完整性保护</strong></p>\n<hr>\n<h3 id=\"网络基础\"><a href=\"#网络基础\" class=\"headerlink\" title=\"网络基础\"></a>网络基础</h3><h4 id=\"TCP-IP协议\"><a href=\"#TCP-IP协议\" class=\"headerlink\" title=\"TCP/IP协议\"></a>TCP/IP协议</h4><ul>\n<li>把与互联网相关的协议集合起来的总称</li>\n<li>应用层（FTP、DNS、HTTP）、传输层（TCP、UDP）、网络层（IP）、数据链路层</li>\n<li>数据传输时候的封装</li>\n<li>IP协议：负责传输，IP地址和MAC地址（ARP协议：解析地址）</li>\n<li>TCP三次握手<ul>\n<li>Client发送带有SYN标志的数据包给对方</li>\n<li>接收端收到并回传一个STYN／ACK标志的数据包</li>\n<li>Client最后回传一个ACK的数据包，表示握手结束</li>\n</ul>\n</li>\n<li>URL：uniform resource location 统一资源定位符</li>\n<li>URI：uniform resource identifier 统一资源标识</li>\n</ul>\n<hr>","more":"<h3 id=\"HTTP协议-无状态协议\"><a href=\"#HTTP协议-无状态协议\" class=\"headerlink\" title=\"HTTP协议(无状态协议)\"></a>HTTP协议(无状态协议)</h3><h4 id=\"HTTP报文：用于HTTP协议交互的信息（报文首部-报文主体）\"><a href=\"#HTTP报文：用于HTTP协议交互的信息（报文首部-报文主体）\" class=\"headerlink\" title=\"HTTP报文：用于HTTP协议交互的信息（报文首部+报文主体）\"></a>HTTP报文：用于HTTP协议交互的信息（报文首部+报文主体）</h4><ul>\n<li>报文主体用于传输实体主体，通常情况下，报文主体等于实体主体，只有在传输过程中进行编码操作时，实体主体内容发生变化，导致与报文主体发生差异</li>\n<li>内容编码：由客户端解码（gzip、compress、deflate、identify）</li>\n<li>分块传输编码：把实体主体分块，由客户端负责解码</li>\n<li>获取部分范围内的请求：首部字段Range，成功206 Partial Content 否则200 OK</li>\n<li>内容协商</li>\n</ul>\n<hr>\n<h4 id=\"请求报文：方法-请求URI-协议版本号-可选请求首部-内容实体\"><a href=\"#请求报文：方法-请求URI-协议版本号-可选请求首部-内容实体\" class=\"headerlink\" title=\"请求报文：方法+请求URI+协议版本号+可选请求首部+内容实体\"></a>请求报文：方法+请求URI+协议版本号+可选请求首部+内容实体</h4><ol>\n<li>方法</li>\n</ol>\n<ul>\n<li>GET：用于请求资源</li>\n<li>POST：用于传输实体的主体</li>\n<li>PUT：用于传输文件（204 No Content，已存在）</li>\n<li>HEAD：获得报文首部，用于确认URI有效期以及资源的更新日期等</li>\n<li>DELETE：删除文件，与PUT相反（204 No Content，已删除）</li>\n<li>OPTIONS：询问支持的方法</li>\n<li>TRACE：用于追踪路径，Max-Forwards</li>\n<li>CONNECT：要求用隧道协议连接代理（要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要是通过SSL和TLS协议把通信内容加密后通过网络隧道传输）</li>\n</ul>\n<ol>\n<li>使用方法下达命令</li>\n<li>持久连接：Keep-alive，只要任意一端没有明确表示要断开，就保持TCP连接状态</li>\n</ol>\n<ul>\n<li>优点：在于减少了 TCP 连接的重复建立和断开所造成的 额外开销,减轻了服务器端的负载。另外,减少开销的那部分时间,使 HTTP 请求和响应能够更早地结束,这样 Web 页面的显示速度也就相应 提高了。</li>\n</ul>\n<ol>\n<li>Pipeling：同时并行发送多个请求</li>\n</ol>\n<hr>\n<h4 id=\"响应报文：协议版本-状态码-解释状态吗的状态短语-可选响应首部-内容实体\"><a href=\"#响应报文：协议版本-状态码-解释状态吗的状态短语-可选响应首部-内容实体\" class=\"headerlink\" title=\"响应报文：协议版本+状态码+解释状态吗的状态短语+可选响应首部+内容实体\"></a>响应报文：协议版本+状态码+解释状态吗的状态短语+可选响应首部+内容实体</h4><hr>\n<h3 id=\"通信数据转发程序-代理、网关、隧道\"><a href=\"#通信数据转发程序-代理、网关、隧道\" class=\"headerlink\" title=\"通信数据转发程序:代理、网关、隧道\"></a>通信数据转发程序:代理、网关、隧道</h3><p>代理：转发时,需要附加 Via 首部字段以标记出经过的主机信息。</p>\n<ul>\n<li>利用缓存技术减少网络带宽的流量，组织内部针对特定网址的访问控制，以获取访问日志为目的</li>\n</ul>\n<p>网管：利用网关可以由 HTTP 请求转化为其他协议通信，提高通信的安全性。</p>\n<p>隧道：隧道的目的是确保客户端能与服务器（远距离）进行安全的通信。</p>\n<hr>\n<h3 id=\"首部\"><a href=\"#首部\" class=\"headerlink\" title=\"首部\"></a>首部</h3><h4 id=\"通用报文首部\"><a href=\"#通用报文首部\" class=\"headerlink\" title=\"通用报文首部\"></a>通用报文首部</h4><ul>\n<li>Cache-Control：缓存机制<ul>\n<li>缓存请求指令：no-cache,no-store,max-age,max-stale,<strong>only-if-cached</strong>(客户端仅在缓存服务器本地缓存目标资源的情况下才会返回，否则504 Gateway Timeout)</li>\n<li>混存响应指令：public,private,no-cache,no-store,must-revalidate,proxy-revalidate</li>\n</ul>\n</li>\n<li>Upgrade：用于检测HTTP协议以及其他协议是否可使用更高的版本进行通信，参数可以是一个完全不同的协议</li>\n<li>Connection：控制不再转发给代理的首部名称，管理持久链接</li>\n<li>Date：报文创建的时间</li>\n<li>Pragma：要求所有的中间服务器不返回缓存的资源</li>\n<li>Trailer：事先说明报文主体里有哪些首部字段</li>\n<li>Transfer-Encoding</li>\n<li>Via：为了追踪传输路径，通常与trace一起使用</li>\n</ul>\n<hr>\n<h4 id=\"请求报文首部\"><a href=\"#请求报文首部\" class=\"headerlink\" title=\"请求报文首部\"></a>请求报文首部</h4><ul>\n<li>Accept</li>\n<li>Accetpt-Charset</li>\n<li>Accept-Language</li>\n<li>Accept-Encoding</li>\n<li>Authorization：用于告知服务器，用户代理的认证信息</li>\n<li>Expect：（否则417）</li>\n<li>From：邮箱</li>\n<li>Host</li>\n<li>If-Match：与ETag相互配合使用</li>\n<li>If-Modified-Since</li>\n<li>If-None-Match</li>\n<li>If-Range</li>\n<li>If-Unmodified-Since</li>\n<li>Max-Forwards</li>\n<li>Proxy-Authorization</li>\n<li>Range</li>\n<li>Referer：URI</li>\n<li>User-Agent</li>\n</ul>\n<hr>\n<h4 id=\"响应报文首部\"><a href=\"#响应报文首部\" class=\"headerlink\" title=\"响应报文首部\"></a>响应报文首部</h4><ul>\n<li>Accept-Ranges：bytes|none</li>\n<li>Age</li>\n<li>ETag：告知客户端实体标识</li>\n<li>Location：URI</li>\n<li>Proxy-Authenticate</li>\n<li>Retry-After</li>\n<li>Server</li>\n<li>Vary：对缓存进行控制</li>\n<li>WWW-Authenticate</li>\n</ul>\n<hr>\n<h4 id=\"实体首部字段\"><a href=\"#实体首部字段\" class=\"headerlink\" title=\"实体首部字段\"></a>实体首部字段</h4><ul>\n<li>Allow</li>\n<li>Content-Encoding</li>\n<li>Content-Language</li>\n<li>Content-Length</li>\n<li>Content-Location</li>\n<li>Content-MD5</li>\n<li>Content-Range</li>\n<li>Content-Types</li>\n<li>Expires</li>\n<li>Last-Modified</li>\n</ul>\n<hr>\n<h4 id=\"Cookie相关\"><a href=\"#Cookie相关\" class=\"headerlink\" title=\"Cookie相关\"></a>Cookie相关</h4><ul>\n<li>响应首部字段：Set-Cookie</li>\n<li>请求首部字段：Cookie</li>\n<li>字段：name,value,domain,path,expires,secure(只有在HTTPS安全通信是才发送Cookie),HttpOnly（使js无法获得Cookie，防止XSS）</li>\n</ul>\n<hr>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>类别</th>\n<th>原因短语</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td>Informational（信息类状态码）</td>\n<td>接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success（成功状态码）</td>\n<td>请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection（重定向状态码）</td>\n<td>需要附加操作才能完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error （客户端出错）</td>\n<td>服务器端无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error（服务端报错）</td>\n<td>服务器端处理请求报错</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h4 id=\"204-No-Content\"><a href=\"#204-No-Content\" class=\"headerlink\" title=\"204 No Content\"></a>204 No Content</h4><p>成功处理，但在返回的响应报文中不包括实体的主体部分<br>一般用于从客户端向服务器端发送信息，而对客户端不需要发送新信息的情况，例如PUT、DELEDTE</p>\n<h4 id=\"206-Partial-Content\"><a href=\"#206-Partial-Content\" class=\"headerlink\" title=\"206 Partial Content\"></a>206 Partial Content</h4><p>表示客户端进行了范围请求，而服务器端成功地执行了这部分请求，响应报文中包含由Content-Range指定范围内的实体内容</p>\n<hr>\n<h4 id=\"301-Move-Permanently\"><a href=\"#301-Move-Permanently\" class=\"headerlink\" title=\"301 Move Permanently\"></a>301 Move Permanently</h4><p>永久性重定向，更新URI</p>\n<h4 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a>302 Found</h4><p>临时重定向，本次更新URI</p>\n<h4 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h4><p>表示请求的资源存在另一个URI，应使用GET获取资源</p>\n<h4 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a>304 Not Modified</h4><p>不包含任何响应的主体部分，一般和缓存相关的首部配合使用（Cacha-Control、If-Modified-Since）</p>\n<h4 id=\"307-Temporary-Redirect\"><a href=\"#307-Temporary-Redirect\" class=\"headerlink\" title=\"307 Temporary Redirect\"></a>307 Temporary Redirect</h4><p>临时重定向，与302不同，307不会把POST改成GET<br>一般301 302 303返回时，基本上所有的浏览器都会把POST更换成GET方法，并删除请求报文中的主体，之后请求会自动再发送</p>\n<hr>\n<h4 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h4><p>请求报文中出现语法错误</p>\n<h4 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h4><p>表示发送的请求需要有通过HTTP认证的信息。包含401的响应必须包含一个适用于被请求资源的WWW-Authenticate的首部用于质询用户信息<br>浏览器收到401响应，会弹出认证用的对话窗口</p>\n<h4 id=\"403-Fobidden\"><a href=\"#403-Fobidden\" class=\"headerlink\" title=\"403 Fobidden\"></a>403 Fobidden</h4><p>访问被拒绝</p>\n<h4 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h4><p>找不到请求的资源</p>\n<hr>\n<h4 id=\"501-Internal-Server-Error\"><a href=\"#501-Internal-Server-Error\" class=\"headerlink\" title=\"501 Internal Server Error\"></a>501 Internal Server Error</h4><p>服务器端在执行请求时候发生了错误</p>\n<h4 id=\"503-Service-Unavaible\"><a href=\"#503-Service-Unavaible\" class=\"headerlink\" title=\"503 Service Unavaible\"></a>503 Service Unavaible</h4><p>服务器端负载超荷活着在维护，无法处理请求。如果知道处理状况的时间，最好加上Retry-After的首部返回客户端</p>"},{"title":"ES6读书笔记","_content":"### let和const\n- **暂时性死区**：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响，使用let命令声明变量之前，该变量都是不可用的\n```javascript\nif (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n\n  typeof x; // ReferenceError\n  let x;\n}\n```\n**for循环变量部分是父作用域，循环体内是子作用域**\n```javascript\nfor (let i = 0; i < 3; i++) {\n  let i = 'abc';\n  console.log(i);\n}\n// abc\n// abc\n// abc\n```\n<!-- more -->\n- **不允许重复声明**:let不允许在相同作用域内，重复声明同一个变量,因此不能在函数内部重新声明参数\n```javascript\nfunction func(arg) {\n  let arg; // 报错\n}\n\nfunction func(arg) {\n  {\n    let arg; // 不报错\n  }\n}\n```\n- **块级作用域与函数声明**\n  - 允许在块级作用域内声明函数。\n  - 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。\n  - 同时，函数声明还会提升到所在的块级作用域的头部\n```javascript\n// 浏览器的 ES6 环境\nfunction f() { console.log('I am outside!'); }\n\n(function () {\n  if (false) {\n    // 重复声明一次函数f\n    function f() { console.log('I am inside!'); }\n  }\n\n  f();\n}());\n// Uncaught TypeError: f is not a function\n```\n- **const:const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动**\n```javascript\nconst a = [];\na.push('Hello'); // 可执行\na.length = 0;    // 可执行\na = ['Dave'];    // 报 错\n```\n常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错\n如果想将对象冻结，应该使用[Object.freeze()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n```javascript\nconst foo = Object.freeze({});\n\n// 常规模式时，下面一行不起作用；\n// 严格模式时，该行会报错\nfoo.prop = 123;\n```\n彻底将对象冻结的函数\n```javascript\nvar deepFreeze = (obj) => {\n  Object.freeze(obj);\n  Object.keys(obj).forEach((key) => {\n    var prop = obj[key]\n    if (prop && typeof prop === 'object' ) {\n      deepFreeze(prop)\n    }\n  });\n};\n// Object.keys不包含对象不可枚举属性，完整版本\nvar deepFreeze = (obj) {\n  Object.freeze(obj)\n  var propNames = Object.getOwnPropertyNames(obj)\n  propNames.forEach((key) => {\n    var prop = obj[key]\n    if (prop && typeof prop === 'object' ) {\n      deepFreeze(prop)\n    }\n  })\n}\n```","source":"_posts/let.md","raw":"---\ntitle: ES6读书笔记\ntags: \n  - ES6\n  - js\n---\n### let和const\n- **暂时性死区**：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响，使用let命令声明变量之前，该变量都是不可用的\n```javascript\nif (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n\n  typeof x; // ReferenceError\n  let x;\n}\n```\n**for循环变量部分是父作用域，循环体内是子作用域**\n```javascript\nfor (let i = 0; i < 3; i++) {\n  let i = 'abc';\n  console.log(i);\n}\n// abc\n// abc\n// abc\n```\n<!-- more -->\n- **不允许重复声明**:let不允许在相同作用域内，重复声明同一个变量,因此不能在函数内部重新声明参数\n```javascript\nfunction func(arg) {\n  let arg; // 报错\n}\n\nfunction func(arg) {\n  {\n    let arg; // 不报错\n  }\n}\n```\n- **块级作用域与函数声明**\n  - 允许在块级作用域内声明函数。\n  - 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。\n  - 同时，函数声明还会提升到所在的块级作用域的头部\n```javascript\n// 浏览器的 ES6 环境\nfunction f() { console.log('I am outside!'); }\n\n(function () {\n  if (false) {\n    // 重复声明一次函数f\n    function f() { console.log('I am inside!'); }\n  }\n\n  f();\n}());\n// Uncaught TypeError: f is not a function\n```\n- **const:const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动**\n```javascript\nconst a = [];\na.push('Hello'); // 可执行\na.length = 0;    // 可执行\na = ['Dave'];    // 报 错\n```\n常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错\n如果想将对象冻结，应该使用[Object.freeze()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n```javascript\nconst foo = Object.freeze({});\n\n// 常规模式时，下面一行不起作用；\n// 严格模式时，该行会报错\nfoo.prop = 123;\n```\n彻底将对象冻结的函数\n```javascript\nvar deepFreeze = (obj) => {\n  Object.freeze(obj);\n  Object.keys(obj).forEach((key) => {\n    var prop = obj[key]\n    if (prop && typeof prop === 'object' ) {\n      deepFreeze(prop)\n    }\n  });\n};\n// Object.keys不包含对象不可枚举属性，完整版本\nvar deepFreeze = (obj) {\n  Object.freeze(obj)\n  var propNames = Object.getOwnPropertyNames(obj)\n  propNames.forEach((key) => {\n    var prop = obj[key]\n    if (prop && typeof prop === 'object' ) {\n      deepFreeze(prop)\n    }\n  })\n}\n```","slug":"let","published":1,"date":"2018-01-02T06:55:15.000Z","updated":"2018-01-02T06:55:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbxa81tp0003dys6t11df7lb","content":"<h3 id=\"let和const\"><a href=\"#let和const\" class=\"headerlink\" title=\"let和const\"></a>let和const</h3><ul>\n<li><strong>暂时性死区</strong>：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响，使用let命令声明变量之前，该变量都是不可用的<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"comment\">// TDZ开始</span></div><div class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// ReferenceError</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> tmp; <span class=\"comment\">// TDZ结束</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\">  tmp = <span class=\"number\">123</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// 123</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">typeof</span> x; <span class=\"comment\">// ReferenceError</span></div><div class=\"line\">  <span class=\"keyword\">let</span> x;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>for循环变量部分是父作用域，循环体内是子作用域</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"string\">'abc'</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(i);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// abc</span></div><div class=\"line\"><span class=\"comment\">// abc</span></div><div class=\"line\"><span class=\"comment\">// abc</span></div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<ul>\n<li><p><strong>不允许重复声明</strong>:let不允许在相同作用域内，重复声明同一个变量,因此不能在函数内部重新声明参数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 报错</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 不报错</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>块级作用域与函数声明</strong></p>\n<ul>\n<li>允许在块级作用域内声明函数。</li>\n<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>\n<li>同时，函数声明还会提升到所在的块级作用域的头部<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 浏览器的 ES6 环境</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</div><div class=\"line\"></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 重复声明一次函数f</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am inside!'</span>); &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  f();</div><div class=\"line\">&#125;());</div><div class=\"line\"><span class=\"comment\">// Uncaught TypeError: f is not a function</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>const:const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> a = [];</div><div class=\"line\">a.push(<span class=\"string\">'Hello'</span>); <span class=\"comment\">// 可执行</span></div><div class=\"line\">a.length = <span class=\"number\">0</span>;    <span class=\"comment\">// 可执行</span></div><div class=\"line\">a = [<span class=\"string\">'Dave'</span>];    <span class=\"comment\">// 报 错</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错<br>如果想将对象冻结，应该使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\" target=\"_blank\" rel=\"external\">Object.freeze()</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">Object</span>.freeze(&#123;&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 常规模式时，下面一行不起作用；</span></div><div class=\"line\"><span class=\"comment\">// 严格模式时，该行会报错</span></div><div class=\"line\">foo.prop = <span class=\"number\">123</span>;</div></pre></td></tr></table></figure></p>\n<p>彻底将对象冻结的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> deepFreeze = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">Object</span>.freeze(obj);</div><div class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prop = obj[key]</div><div class=\"line\">    <span class=\"keyword\">if</span> (prop &amp;&amp; <span class=\"keyword\">typeof</span> prop === <span class=\"string\">'object'</span> ) &#123;</div><div class=\"line\">      deepFreeze(prop)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// Object.keys不包含对象不可枚举属性，完整版本</span></div><div class=\"line\"><span class=\"keyword\">var</span> deepFreeze = (obj) &#123;</div><div class=\"line\">  <span class=\"built_in\">Object</span>.freeze(obj)</div><div class=\"line\">  <span class=\"keyword\">var</span> propNames = <span class=\"built_in\">Object</span>.getOwnPropertyNames(obj)</div><div class=\"line\">  propNames.forEach(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prop = obj[key]</div><div class=\"line\">    <span class=\"keyword\">if</span> (prop &amp;&amp; <span class=\"keyword\">typeof</span> prop === <span class=\"string\">'object'</span> ) &#123;</div><div class=\"line\">      deepFreeze(prop)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"let和const\"><a href=\"#let和const\" class=\"headerlink\" title=\"let和const\"></a>let和const</h3><ul>\n<li><strong>暂时性死区</strong>：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响，使用let命令声明变量之前，该变量都是不可用的<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"comment\">// TDZ开始</span></div><div class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// ReferenceError</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> tmp; <span class=\"comment\">// TDZ结束</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\">  tmp = <span class=\"number\">123</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// 123</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">typeof</span> x; <span class=\"comment\">// ReferenceError</span></div><div class=\"line\">  <span class=\"keyword\">let</span> x;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>for循环变量部分是父作用域，循环体内是子作用域</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"string\">'abc'</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(i);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// abc</span></div><div class=\"line\"><span class=\"comment\">// abc</span></div><div class=\"line\"><span class=\"comment\">// abc</span></div></pre></td></tr></table></figure></p>","more":"<ul>\n<li><p><strong>不允许重复声明</strong>:let不允许在相同作用域内，重复声明同一个变量,因此不能在函数内部重新声明参数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 报错</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 不报错</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>块级作用域与函数声明</strong></p>\n<ul>\n<li>允许在块级作用域内声明函数。</li>\n<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>\n<li>同时，函数声明还会提升到所在的块级作用域的头部<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 浏览器的 ES6 环境</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</div><div class=\"line\"></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 重复声明一次函数f</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am inside!'</span>); &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  f();</div><div class=\"line\">&#125;());</div><div class=\"line\"><span class=\"comment\">// Uncaught TypeError: f is not a function</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>const:const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> a = [];</div><div class=\"line\">a.push(<span class=\"string\">'Hello'</span>); <span class=\"comment\">// 可执行</span></div><div class=\"line\">a.length = <span class=\"number\">0</span>;    <span class=\"comment\">// 可执行</span></div><div class=\"line\">a = [<span class=\"string\">'Dave'</span>];    <span class=\"comment\">// 报 错</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错<br>如果想将对象冻结，应该使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\" target=\"_blank\" rel=\"external\">Object.freeze()</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">Object</span>.freeze(&#123;&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 常规模式时，下面一行不起作用；</span></div><div class=\"line\"><span class=\"comment\">// 严格模式时，该行会报错</span></div><div class=\"line\">foo.prop = <span class=\"number\">123</span>;</div></pre></td></tr></table></figure></p>\n<p>彻底将对象冻结的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> deepFreeze = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">Object</span>.freeze(obj);</div><div class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prop = obj[key]</div><div class=\"line\">    <span class=\"keyword\">if</span> (prop &amp;&amp; <span class=\"keyword\">typeof</span> prop === <span class=\"string\">'object'</span> ) &#123;</div><div class=\"line\">      deepFreeze(prop)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// Object.keys不包含对象不可枚举属性，完整版本</span></div><div class=\"line\"><span class=\"keyword\">var</span> deepFreeze = (obj) &#123;</div><div class=\"line\">  <span class=\"built_in\">Object</span>.freeze(obj)</div><div class=\"line\">  <span class=\"keyword\">var</span> propNames = <span class=\"built_in\">Object</span>.getOwnPropertyNames(obj)</div><div class=\"line\">  propNames.forEach(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prop = obj[key]</div><div class=\"line\">    <span class=\"keyword\">if</span> (prop &amp;&amp; <span class=\"keyword\">typeof</span> prop === <span class=\"string\">'object'</span> ) &#123;</div><div class=\"line\">      deepFreeze(prop)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"关于this","date":"2017-09-26T07:04:58.000Z","_content":"### [this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)\n- 无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this都指代全局对象(window||global)。\n- 在函数内部，this的值取决于函数被调用的方式,可以通过call或apply改变this的值\n```javascript\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nvar o = {a: 1, b: 3};\n\n// The first parameter is the object to use as\n// 'this', subsequent parameters are passed as \n// arguments in the function call\nadd.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16\n\n// The first parameter is the object to use as\n// 'this', the second is an array whose\n// members are used as the arguments in the function call\nadd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34\n```\n<!-- more -->\n### bind\n调用f.bind(某个对象)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将**永久地被绑定**到了bind的第一个参数，无论这个函数是如何被调用的\n```javascript\nfunction f() {\n  return this.a;\n}\n\nvar g = f.bind({a: 'azerty'});\nconsole.log(g()); // azerty\n\nvar h = g.bind({a: 'yoo'}); // bind only works once!\nconsole.log(h()); // azerty\n\nvar o = {a: 37, f: f, g: g, h: h};\nconsole.log(o.f(), o.g(), o.h()); // 37, azerty, azerty\n```\n### bind call apply三者的异同\n### 如何实现bind\n```javascript\nfunction.prototype.bind = function() {\n  var fc = this // 指向实际调用bind的fucntion\n  var thisArg = Array.prototype.slice.call(arguments,0,1)\n  return function() {\n    return fc.apply(thisArg)\n  }\n}\n```","source":"_posts/this.md","raw":"---\ntitle: 关于this\ntags: \n  - js\ndate: 2017-09-26 15:04:58\n---\n### [this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)\n- 无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this都指代全局对象(window||global)。\n- 在函数内部，this的值取决于函数被调用的方式,可以通过call或apply改变this的值\n```javascript\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nvar o = {a: 1, b: 3};\n\n// The first parameter is the object to use as\n// 'this', subsequent parameters are passed as \n// arguments in the function call\nadd.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16\n\n// The first parameter is the object to use as\n// 'this', the second is an array whose\n// members are used as the arguments in the function call\nadd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34\n```\n<!-- more -->\n### bind\n调用f.bind(某个对象)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将**永久地被绑定**到了bind的第一个参数，无论这个函数是如何被调用的\n```javascript\nfunction f() {\n  return this.a;\n}\n\nvar g = f.bind({a: 'azerty'});\nconsole.log(g()); // azerty\n\nvar h = g.bind({a: 'yoo'}); // bind only works once!\nconsole.log(h()); // azerty\n\nvar o = {a: 37, f: f, g: g, h: h};\nconsole.log(o.f(), o.g(), o.h()); // 37, azerty, azerty\n```\n### bind call apply三者的异同\n### 如何实现bind\n```javascript\nfunction.prototype.bind = function() {\n  var fc = this // 指向实际调用bind的fucntion\n  var thisArg = Array.prototype.slice.call(arguments,0,1)\n  return function() {\n    return fc.apply(thisArg)\n  }\n}\n```","slug":"this","published":1,"updated":"2018-01-02T06:55:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbxa81tq0004dys66pyqvut5","content":"<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"external\">this</a></h3><ul>\n<li>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this都指代全局对象(window||global)。</li>\n<li>在函数内部，this的值取决于函数被调用的方式,可以通过call或apply改变this的值<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">c, d</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + <span class=\"keyword\">this</span>.b + c + d;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">3</span>&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// The first parameter is the object to use as</span></div><div class=\"line\"><span class=\"comment\">// 'this', subsequent parameters are passed as </span></div><div class=\"line\"><span class=\"comment\">// arguments in the function call</span></div><div class=\"line\">add.call(o, <span class=\"number\">5</span>, <span class=\"number\">7</span>); <span class=\"comment\">// 1 + 3 + 5 + 7 = 16</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// The first parameter is the object to use as</span></div><div class=\"line\"><span class=\"comment\">// 'this', the second is an array whose</span></div><div class=\"line\"><span class=\"comment\">// members are used as the arguments in the function call</span></div><div class=\"line\">add.apply(o, [<span class=\"number\">10</span>, <span class=\"number\">20</span>]); <span class=\"comment\">// 1 + 3 + 10 + 20 = 34</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><p>调用f.bind(某个对象)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将<strong>永久地被绑定</strong>到了bind的第一个参数，无论这个函数是如何被调用的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> g = f.bind(&#123;<span class=\"attr\">a</span>: <span class=\"string\">'azerty'</span>&#125;);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(g()); <span class=\"comment\">// azerty</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> h = g.bind(&#123;<span class=\"attr\">a</span>: <span class=\"string\">'yoo'</span>&#125;); <span class=\"comment\">// bind only works once!</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(h()); <span class=\"comment\">// azerty</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">a</span>: <span class=\"number\">37</span>, <span class=\"attr\">f</span>: f, <span class=\"attr\">g</span>: g, <span class=\"attr\">h</span>: h&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(o.f(), o.g(), o.h()); <span class=\"comment\">// 37, azerty, azerty</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"bind-call-apply三者的异同\"><a href=\"#bind-call-apply三者的异同\" class=\"headerlink\" title=\"bind call apply三者的异同\"></a>bind call apply三者的异同</h3><h3 id=\"如何实现bind\"><a href=\"#如何实现bind\" class=\"headerlink\" title=\"如何实现bind\"></a>如何实现bind</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>.<span class=\"title\">prototype</span>.<span class=\"title\">bind</span> = <span class=\"title\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> fc = <span class=\"keyword\">this</span> <span class=\"comment\">// 指向实际调用bind的fucntion</span></div><div class=\"line\">  <span class=\"keyword\">var</span> thisArg = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>)</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> fc.apply(thisArg)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"external\">this</a></h3><ul>\n<li>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this都指代全局对象(window||global)。</li>\n<li>在函数内部，this的值取决于函数被调用的方式,可以通过call或apply改变this的值<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">c, d</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + <span class=\"keyword\">this</span>.b + c + d;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">3</span>&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// The first parameter is the object to use as</span></div><div class=\"line\"><span class=\"comment\">// 'this', subsequent parameters are passed as </span></div><div class=\"line\"><span class=\"comment\">// arguments in the function call</span></div><div class=\"line\">add.call(o, <span class=\"number\">5</span>, <span class=\"number\">7</span>); <span class=\"comment\">// 1 + 3 + 5 + 7 = 16</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// The first parameter is the object to use as</span></div><div class=\"line\"><span class=\"comment\">// 'this', the second is an array whose</span></div><div class=\"line\"><span class=\"comment\">// members are used as the arguments in the function call</span></div><div class=\"line\">add.apply(o, [<span class=\"number\">10</span>, <span class=\"number\">20</span>]); <span class=\"comment\">// 1 + 3 + 10 + 20 = 34</span></div></pre></td></tr></table></figure>\n</li>\n</ul>","more":"<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><p>调用f.bind(某个对象)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将<strong>永久地被绑定</strong>到了bind的第一个参数，无论这个函数是如何被调用的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> g = f.bind(&#123;<span class=\"attr\">a</span>: <span class=\"string\">'azerty'</span>&#125;);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(g()); <span class=\"comment\">// azerty</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> h = g.bind(&#123;<span class=\"attr\">a</span>: <span class=\"string\">'yoo'</span>&#125;); <span class=\"comment\">// bind only works once!</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(h()); <span class=\"comment\">// azerty</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">a</span>: <span class=\"number\">37</span>, <span class=\"attr\">f</span>: f, <span class=\"attr\">g</span>: g, <span class=\"attr\">h</span>: h&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(o.f(), o.g(), o.h()); <span class=\"comment\">// 37, azerty, azerty</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"bind-call-apply三者的异同\"><a href=\"#bind-call-apply三者的异同\" class=\"headerlink\" title=\"bind call apply三者的异同\"></a>bind call apply三者的异同</h3><h3 id=\"如何实现bind\"><a href=\"#如何实现bind\" class=\"headerlink\" title=\"如何实现bind\"></a>如何实现bind</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>.<span class=\"title\">prototype</span>.<span class=\"title\">bind</span> = <span class=\"title\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> fc = <span class=\"keyword\">this</span> <span class=\"comment\">// 指向实际调用bind的fucntion</span></div><div class=\"line\">  <span class=\"keyword\">var</span> thisArg = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>)</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> fc.apply(thisArg)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjbxa81t80000dys68cwmqpu5","tag_id":"cjbxa81tm0001dys6tt27xiyp","_id":"cjbxa81to0002dys6bn6ghvpz"},{"post_id":"cjbxa81tp0003dys6t11df7lb","tag_id":"cjbxa81tr0005dys6v1y9biks","_id":"cjbxa81tt0008dys6fdo5zinp"},{"post_id":"cjbxa81tp0003dys6t11df7lb","tag_id":"cjbxa81ts0006dys6jzlgo4en","_id":"cjbxa81tt0009dys634qrb3zn"},{"post_id":"cjbxa81tq0004dys66pyqvut5","tag_id":"cjbxa81ts0006dys6jzlgo4en","_id":"cjbxa81tt000adys6jsvx2z3x"}],"Tag":[{"name":"http","_id":"cjbxa81tm0001dys6tt27xiyp"},{"name":"ES6","_id":"cjbxa81tr0005dys6v1y9biks"},{"name":"js","_id":"cjbxa81ts0006dys6jzlgo4en"}]}}